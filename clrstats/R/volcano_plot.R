
volcanoPlot <- function(stats, meas, interaction, thresh=NULL, 
                        log.scale.x=TRUE, labels=TRUE, plot.size=c(5, 7), 
                        size.mult=3, meas.names=NULL) {
  # Generate a volcano plot.
  #
  # Args:
  #   stats: Data frame generated by \code{\link{filterStats}}.
  #   meas: Measurement to display in plot title.
  #   interaction: Interaction column name whose set of stats should be 
  #     displayed.
  #   thresh: Threshold as a 3-element array corresponding to the x, y, and  
  #     size (0-1 scale), respectively, above which labels will be shown if 
  #     all conditions are met. NA for any value will cause the threshold to 
  #     be ignored, or NA for the entire argument will ignore thresholding 
  #     all together.
  #   log.scale.x: True to scale x-axis by log10, first normalizing to 
  #     the minimum x-value before taking the log of the absolute value 
  #     to avoid negative log values, then returning to the original sign.
  #   plot.size: Vector of width, height for exported plot; defaults to 
  #     c(5, 7).
  #   size.mult: Point size multiplier; defaults to 3.
  #   meas.names: Named nested list whose sublists' first element will 
  #     specify the title, with names corresponding to meas. Defaults to 
  #     NULL to use a default title.
  
  x <- stats[[paste0(interaction, ".effect")]]
  num.x <- length(x)
  if (num.x < 1) {
    cat("no values found to generate volcano plot, skipping\n")
    return()
  }
  y <- stats[[paste0(interaction, ".logp")]]
  # weight size based on mean volume, replacing NaNs with a small num
  vol <- stats$Volume
  if (isTRUE(all.equal(vol, rep(0, num.x)))) {
    size <- rep(1, num.x)
  } else {
    vol[is.nan(vol) | vol == 0] <- 1
    size <- sqrt(vol / max(vol))
  }
  #print(data.frame(x, size))
  
  parents <- stats$Parent
  if (length(parents) > 0) {
    # point colors based on IDs of parents at the level generated for region 
    # IDs file, using a palette with color for each unique parent
    parents.unique <- unique(parents)
    parents.indices <- match(parents, parents.unique)
    colors <- RColorBrewer::brewer.pal(length(parents.unique), "Paired")
    colors.parents <- colors[parents.indices]
  } else {
    # default to blue color for all points
    colors.parents <- "blue"
  }
  
  # base plot -log p vs effect size
  xlab <- "Effects"
  if (log.scale.x) {
    # apply a log-modulus transform to allow non-positive values as input
    # and to ensure that output is >=0; also apply to threshold x-value
    x <- logModulusTransform(x)
    xlab <- "Effects (log-transformed)"
    thresh[[1]] <- logModulusTransform(thresh[[1]])
  }
  
  # x-lims based on points above y-thresh and size thresh if each are given; 
  # fall back to ignoring thresholds if no points meet criteria
  x.threshed <- x
  x.thresh <- NULL
  if (!is.na(thresh[2])) x.thresh <- y > thresh[2]
  if (!is.na(thresh[3])) x.thresh <- x.thresh & size > thresh[3]
  if (!is.null(x.thresh)) x.threshed <- x[x.thresh]
  x.max <- max(abs(x.threshed))
  if (is.infinite(x.max)) x.max <- max(abs(x))
  
  # use custom title if available from named list
  if (!is.null(meas.names) & is.element(meas, names(meas.names))) {
    # assumed to contain a sublist with title listed first
    title <- meas.names[[meas]][1]
  } else {
    title <- paste(meas, "Differences for", interaction)
  }

  # set up plot saving
  ext <- ".pdf"
  path.plot <- file.path(
    if(exists("config.env")) config.env$Prefix else "..",
    paste0("plot_volcano_", gsub("/| ", "_", title), ext))
  dev.fn <- getDevice(ext)
  if (!interactive()) {
    # open PDF device
    openPlotDevice(dev.fn, path.plot, plot.size)
  }

  # scatter plot with vertical line to denote x = 0
  plot(
    x, y, xlim=c(-1 * x.max, x.max), 
    main=title, xlab=xlab, 
    ylab="-log10(p)", type="p", las=1, pch=16, cex=(size*size.mult), 
    col=colors.parents)
  abline(v=0, lty="dashed", col=gray(0.5, 0.5))
  
  # label points
  x.lbl <- x
  y.lbl <- y
  lbls <- stats$RegionAbbr
  if (!is.null(thresh)) {
    # limit labels only to those within all thresholds, ignoring NAs
    show.lbl <- abs(x) > 0
    if (!is.na(thresh[1])) show.lbl <- abs(x) > thresh[1] & show.lbl
    if (!is.na(thresh[2])) show.lbl <- y > thresh[2] & show.lbl
    x.lbl <- x[show.lbl]
    y.lbl <- y[show.lbl]
    lbls <- lbls[show.lbl]
  }
  if (labels & length(lbls) > 0) {
    # place text labels; "text" has full overlap, "thigmophobe.labels" and 
    # "pointLabels" have varying degrees of overlap, and "addTextLabels" has 
    # the least overlap
    #text(x.lbl, y.lbl, label=lbls, cex=0.2)
    #thigmophobe.labels(x.lbl, y.lbl, label=lbls, cex=0.2)
    #pointLabel(x.lbl, y.lbl, label=lbls, cex=0.2)
    basicPlotteR::addTextLabels(
      x.lbl, y.lbl, label=lbls, cex.label=0.5, lwd=0.5)
  }

  # save plot in interactive mode and reset device if necessary
  finalizeDevice(dev.fn, path.plot, plot.size)
}

logModulusTransform <- function(vals, shift=1) {
  # Transform data with a log modulus transformation.
  #
  # Args:
  #   vals: Sequence to transform.
  #   shift: Amount by which to shift the absolute value of the data prior
  #     to taking the log; defaults to 1.
  
  vals.trans <- sign(vals) * log10(abs(vals) + shift)
  return(vals.trans)
}
